
#Область ВспомогательныеФункции

Функция ПолучитьСоответствияСтандартов()
	лСоответствиеСтандартаИАлгоритма = Новый Соответствие;
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA-224",    Новый Структура("Битность,Размер",256,"224"));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA-256",    Новый Структура("Битность,Размер",256,"256"));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA-512/224",Новый Структура("Битность,Размер",512,"224"));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA-512/256",Новый Структура("Битность,Размер",512,"256"));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA-384",    Новый Структура("Битность,Размер",512,"384"));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA-512",    Новый Структура("Битность,Размер",512,"512"));
	Возврат лСоответствиеСтандартаИАлгоритма;
КонецФункции // ПолучитьСоответствияСтандартов()

Функция ПолучитьСоответствияСтандартов3()
	лСоответствиеСтандартаИАлгоритма = Новый Соответствие;
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA3-128",Новый Структура("Битность,Суффикс,Размер",256,"06",128));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA3-224",Новый Структура("Битность,Суффикс,Размер",448,"06",224));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA3-256",Новый Структура("Битность,Суффикс,Размер",512,"06",256));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA3-384",Новый Структура("Битность,Суффикс,Размер",768,"06",384));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHA3-512",Новый Структура("Битность,Суффикс,Размер",1024,"06",512));
	лСоответствиеСтандартаИАлгоритма.Вставить("Keccak-256",Новый Структура("Битность,Суффикс,Размер",512,"01",256));
	лСоответствиеСтандартаИАлгоритма.Вставить("Keccak-512",Новый Структура("Битность,Суффикс,Размер",1024,"01",512));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHAKE128",Новый Структура("Битность,Суффикс,Размер",256,"1f","256"));
	лСоответствиеСтандартаИАлгоритма.Вставить("SHAKE256",Новый Структура("Битность,Суффикс,Размер",512,"1f","512"));
	лСоответствиеСтандартаИАлгоритма.Вставить("cSHAKE128",Новый Структура("Битность,Суффикс,Размер",256,"00","256"));
	лСоответствиеСтандартаИАлгоритма.Вставить("cSHAKE256",Новый Структура("Битность,Суффикс,Размер",512,"00","512"));
	Возврат лСоответствиеСтандартаИАлгоритма;
КонецФункции // ПолучитьСоответствияСтандартов3(пКлюч)

#КонецОбласти

#Область ОбработкаДанных

Функция ПовторитьСтроку(пСтрока, пКоличество)
	лЧасти = Новый Массив;
	Для к = 1 По пКоличество Цикл
		лЧасти.Добавить(пСтрока);
	КонецЦикла;
	Возврат СтрСоединить(лЧасти, "");
КонецФункции // ПовторитьСтроку(пСтрока, пКоличество)

Функция СклеитьДвоичныеДанные(пДвоичныеДанные1, пДвоичныеДанные2)
	лМассивДвоичныхДанных = Новый Массив;
	лМассивДвоичныхДанных.Добавить(пДвоичныеДанные1);
	лМассивДвоичныхДанных.Добавить(пДвоичныеДанные2);
	Возврат СоединитьДвоичныеДанные(лМассивДвоичныхДанных);
КонецФункции // СклеитьДвоичныеДанные(пДвоичныеДанные1, пДвоичныеДанные2)

Функция СклеитьБуферыДвоичныхДанных(Буфер1, Буфер2)
	
	МассивДвоичныхДанных = Новый Массив;
	МассивДвоичныхДанных.Добавить(Буфер1);
	МассивДвоичныхДанных.Добавить(Буфер2);
	
	Возврат СоединитьБуферыДвоичныхДанных(МассивДвоичныхДанных);
	
КонецФункции

// Функция получает массив буферов двоичных данных из HEX строки с разделителями запятыми
// пример: "428A2F98,71374491,B5C0FBCF"
//
Функция ПолучитьМассивБДДИзHexСтроки(Знач пСтрока)
	лПоз = Найти(пСтрока,",");
	лМассив = Новый Массив;
	Пока лПоз>1 Цикл
		лПодстрока = Сред(пСтрока,1,лПоз-1);
		пСтрока = Сред(пСтрока,лПоз+1);
		лПоз = Найти(пСтрока,",");
		лМассив.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки(лПодстрока));
	КонецЦикла;
	лМассив.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки(пСтрока));
	Возврат лМассив;
КонецФункции // ПолучитьМассивБДДИзHexСтроки(Знач пСтрока)

Функция ПолучитьМассивЧиселИзHexСтроки(Знач пСтрока)
	лПоз = Найти(пСтрока,",");
	лМассив = Новый Массив;
	Пока лПоз>1 Цикл
		лПодстрока = Сред(пСтрока,1,лПоз-1);
		пСтрока = Сред(пСтрока,лПоз+1);
		лПоз = Найти(пСтрока,",");
		лМассив.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки(лПодстрока).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian));
	КонецЦикла;
	лМассив.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки(пСтрока).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian));
	Возврат лМассив;
КонецФункции // ПолучитьМассивБДДИзHexСтроки(Знач пСтрока)

#Область ПобитовыеОперации

// функция осуществляет циклический сдвиг влево
//
Функция ЦиклическийСдвигВлево(Знач пЧисло, Знач пСмещение)
	Возврат(ПобитовыйСдвигВправо(пЧисло, 32-пСмещение) + ПобитовыйСдвигВлево(пЧисло, пСмещение));
КонецФункции // ЦиклическийСдвигВлево(Знач пЧисло, Знач пСмещение)

// функция осуществляет циклический сдвиг вправо
//
Функция ЦиклическийСдвигВправо(Знач пЧисло, Знач пСмещение)
	Возврат(ПобитовыйСдвигВправо(пЧисло, пСмещение) + ПобитовыйСдвигВлево(пЧисло,32-пСмещение));
КонецФункции // ЦиклическийСдвигВлево(Знач пЧисло, Знач пСмещение)

Функция ПривестиК32Битам(Знач пЧисло)
	Возврат пЧисло%4294967296;
КонецФункции // ПривестиК32Битам(Знач пЧисло)

// функция осуществляет циклический сдвиг влево
//
Функция ЦиклическийСдвигВлево64(пМассивСтепеней2,пЧисло, пСмещение)
	Возврат ПривестиК64Битам(Цел(пЧисло/пМассивСтепеней2[64-пСмещение]) + пЧисло*пМассивСтепеней2[пСмещение]);
КонецФункции // ЦиклическийСдвигВлево64(пЧисло, пСмещение)

// функция осуществляет циклический сдвиг вправо
//
Функция ЦиклическийСдвигВправо64(пМассивСтепеней2,пЧисло, пСмещение)
	Возврат ПривестиК64Битам(Цел(пЧисло/пМассивСтепеней2[пСмещение]) + пЧисло*пМассивСтепеней2[64-пСмещение]);
КонецФункции // ЦиклическийСдвигВправо64(пЧисло, пСмещение)

Функция ПобитовыйСдвигВправо64(пМассивСтепеней2,пЧисло, пСмещение)
	Возврат Цел(пЧисло/пМассивСтепеней2[пСмещение])
КонецФункции // ПобитовыйСдвигВправо64(пЧисло, пСмещение)

Функция ПобитовыйСдвигВлево64(пМассивСтепеней2,пЧисло, пСмещение)
	ПривестиК64Битам(пЧисло*пМассивСтепеней2[пСмещение]);
КонецФункции // ПобитовыйСдвигВлево64(пЧисло, пСмещение)

Функция ПобитовоеИсключительноеИли64(пЧисло1, пЧисло2)
	лЧисло10 = Цел(пЧисло1/4294967296);
	лЧисло11 = пЧисло1%4294967296;
	лЧисло20 = Цел(пЧисло2/4294967296);
	лЧисло21 = пЧисло2%4294967296;
	Возврат (ПобитовоеИсключительноеИли(лЧисло10,лЧисло20)*4294967296+ПобитовоеИсключительноеИли(лЧисло11,лЧисло21));
КонецФункции // ПобитовоеИсключительноеИли64(пЧисло1, пЧисло2)

Функция ПобитовоеИ64(пЧисло1, пЧисло2)
	лЧисло10 = Цел(пЧисло1/4294967296);
	лЧисло11 = пЧисло1%4294967296;
	лЧисло20 = Цел(пЧисло2/4294967296);
	лЧисло21 = пЧисло2%4294967296;
	Возврат (ПобитовоеИ(лЧисло10,лЧисло20)*4294967296+ПобитовоеИ(лЧисло11,лЧисло21));
КонецФункции // ПобитовоеИ64(пЧисло1, пЧисло2)

Функция ПобитовоеНе64(пЧисло1)
	лЧисло10 = Цел(пЧисло1/4294967296);
	лЧисло11 = пЧисло1%4294967296;
	Возврат (ПобитовоеНе(лЧисло10)*4294967296+ПобитовоеНе(лЧисло11));
КонецФункции // ПобитовоеНе64(пЧисло1)

Функция ПривестиК64Битам(пЧисло)
	Если пЧисло<18446744073709551616 Тогда
		Возврат пЧисло
	Иначе
		Возврат пЧисло%18446744073709551616;
	КонецЕсли;
КонецФункции // ПривестиК64Битам(пЧисло)

// Функция получения Hex строки из подстрок бит префикса и суффикса с нулями между ними 
// - не используется
//  параметры:
//  пПрефикс - строка с битами префикса
//  пСуффикс - строка с битами суффикса
//  пДлина - число, длина результата в битах
// 
Функция Bin2Hex(пПрефикс="", пСуффикс="", пДлина = 8)
	лОбщаяДлина = СтрДлина(пПрефикс)+СтрДлина(пСуффикс);
	лСтрBin = пПрефикс+ПовторитьСтроку("0",пДлина-лОбщаяДлина)+пСуффикс;
	лЧисло = 0;
	Для н=1 По пДлина Цикл
		лБит = Сред(лСтрBin,н,1);
		лЧисло = лЧисло + Pow(2,пДлина-н)*Число(лБит);
	КонецЦикла;
	лБуф = Новый БуферДвоичныхДанных(8, ПорядокБайтов.BigEndian);
	лБуф.ЗаписатьЦелое64(0, лЧисло,ПорядокБайтов.BigEndian);
	Возврат Прав(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(лБуф), пДлина/4);
	
	// Этот вариант чуть медленнее:
	
	//лОбщаяДлина = СтрДлина(пПрефикс)+СтрДлина(пСуффикс);
	//лСтрBin = пПрефикс+ПовторитьСтроку("0",пДлина-лОбщаяДлина)+пСуффикс;
	//лСтр16 = "0123456789ABCDEF";
	//лЧисло = 0;
	//лСтр = "";
	//Для н=1 По пДлина Цикл
	//	лБит = Сред(лСтрBin,н,1);
	//	лЧисло = лЧисло + Pow(2,пДлина-н)*Число(лБит);
	//	Если н%4=0 Тогда
	//		лСтр = лСтр + Сред(лСтр16,лЧисло+1,1);
	//		лЧисло = 0;
	//	КонецЕсли;
	//КонецЦикла;
	//Возврат лСтр;
КонецФункции // Bin2Hex(пПрефикс="", пСуффикс="", пДлина = 8)

Функция СложитьHex(Знач пСуффикс1, Знач пСуффикс2)
	лСтрокаHex = "0123456789abcdef";
	пСуффикс1 = нРег(пСуффикс1);
	пСуффикс2 = НРег(пСуффикс2);
	н1=0;
	н2=0;
	Колво1 = СтрДлина(пСуффикс1);
	Колво2 = СтрДлина(пСуффикс2);
	лВыхСтрока = "";
	лПереносРазряда = 0;
	лФл = Истина;
	Пока лФл Цикл
		лФл = Ложь;
		лЧисло1 = 0;
		лЧисло2 = 0;
		Если н1<Колво1 Тогда
			лСимв1 = Сред(пСуффикс1,Колво1-н1,1);
			лЧисло1 = СтрНайти(лСтрокаHex,лСимв1)-1;
			лФл = Истина;
		КонецЕсли;
		Если н2<Колво2 Тогда
			лСимв2 = Сред(пСуффикс2,Колво2-н2,1);
			лЧисло2 = СтрНайти(лСтрокаHex,лСимв2)-1;
			лФл = Истина;
		КонецЕсли;
		лЧисло3 = лЧисло1+лЧисло2+лПереносРазряда;
		лПереносРазряда = 0;
		Если лЧисло3>15 Тогда
			лЧисло3 = 0;
			лПереносРазряда = 1;
		КонецЕсли;
		Если лФл Тогда
			лВыхСтрока = Сред(лСтрокаHex,лЧисло3+1,1) + лВыхСтрока;
		КонецЕсли;
		н1 = н1 + 1;
		н2 = н2 + 1;
	КонецЦикла;
	Если лПереносРазряда>0 Тогда
		лВыхСтрока = Сред(лСтрокаHex,лПереносРазряда+1,1) + лВыхСтрока;
	КонецЕсли;
	Если СтрДлина(лВыхСтрока)%2<>0 Тогда
		лВыхСтрока = "0" + лВыхСтрока;
	КонецЕсли;
	Возврат лВыхСтрока;
КонецФункции

#КонецОбласти

Функция ПолучитьМассивСтепеней2()
	лМассивСтепеней2 = Новый Массив;
	Для н=0 по 64 Цикл
		лМассивСтепеней2.Добавить(pow(2,н));
	КонецЦикла;
	Возврат лМассивСтепеней2;
КонецФункции
	
#КонецОбласти

#Область SHA2

// Функция расчета Хеша по алгоритму SHA2
// Входные параметры:
//  пДанные - двоичные данные
//  пСтандарт - Строка с описанием стандарта по которому нужно рассчитать Hash. Варианты:
//   "SHA2-224", "SHA2-256", "SHA2-512", "SHA2-512/384", "SHA2-512/256", "SHA2-512/224"
// Возвращаяет HEX строку с хешем
//
Функция SHA2(пДанные, пСтандарт="SHA-512") Экспорт
	
	СоответствиеСтандартаИАлгоритма = ПолучитьСоответствияСтандартов();
	лТекСтандарт = СоответствиеСтандартаИАлгоритма[пСтандарт];
	лДанныеБуфер = ПолучитьБуферДвоичныхДанныхИзСтроки(пДанные);
	Если лТекСтандарт.Битность>256 Тогда
		Возврат ПолучитьHexСтрокуИзБуфераДвоичныхДанных(SHA512(лДанныеБуфер, лТекСтандарт.Размер));
	Иначе
		Возврат ПолучитьHexСтрокуИзБуфераДвоичныхДанных(SHA256(лДанныеБуфер, лТекСтандарт.Размер));
	КонецЕсли;
КонецФункции // SHA2(пДанные, пСтандарт="SHA-512") Экспорт

// Функция расчета Хеша по алгоритму SHA2 HMAC с ключом и требуемой разрядностью
// Входные параметры:
//  пКлюч - ключ, строка или двоичные данные
//  пДанные - строка или двоичные данные
//  пСтандарт - Строка с описанием стандарта по которому нужно рассчитать Hash. Варианты:
//   "SHA2-224", "SHA2-256", "SHA2-512", "SHA2-512/384", "SHA2-512/256", "SHA2-512/224"
// Возвращаяет HEX строку с хешем
//
Функция HMAC2(пКлюч, пДанные, пСтандарт = "SHA-256") Экспорт
	
	СоответствиеСтандартаИАлгоритма = ПолучитьСоответствияСтандартов();
	
	// Подготовка параметров
	ДанныеДв = ПолучитьБуферДвоичныхДанныхИзСтроки(пДанные);
	КлючБуфер = ПолучитьБуферДвоичныхДанныхИзСтроки(пКлюч);
	
	лТекСтандарт = СоответствиеСтандартаИАлгоритма[пСтандарт];
	
	Если лТекСтандарт.Битность>256 Тогда
		РазмерБлока = 128;
	Иначе
		РазмерБлока = 64;
	КонецЕсли;
	
	// Подготовка ключа
	Если КлючБуфер.Размер > РазмерБлока Тогда
		КлючБуфер = SHA2_(КлючБуфер, лТекСтандарт.Битность, лТекСтандарт.Размер);
	КонецЕсли;	
	opad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("5c", РазмерБлока));
	ipad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("36", РазмерБлока));
	ipad.ЗаписатьПобитовоеИсключительноеИли(0, КлючБуфер);
	opad.ЗаписатьПобитовоеИсключительноеИли(0, КлючБуфер);
	Возврат ПолучитьHexСтрокуИзБуфераДвоичныхДанных(SHA2_(СклеитьБуферыДвоичныхДанных(opad, SHA2_(СклеитьБуферыДвоичныхДанных(ipad, ДанныеДв), лТекСтандарт.Битность, лТекСтандарт.Размер)),лТекСтандарт.Битность, лТекСтандарт.Размер));
	
КонецФункции // HMAC2(пКлюч, пДанные, пСтандарт = "SHA-256") Экспорт

// Функция расчета Хеша по алгоритму SHA-512 с ключом
// Входные параметры:
// пКлюч - строка с ключом, неограниченная, приводится к длине блока - 128
// пДанные - строка с данными, неограниченная
// Возвращаяет Hex строку с хешем
//
Функция HMAC512(пКлюч, пДанные, РазмерБлока = 128) Экспорт
	
	ДанныеДв = ПолучитьБуферДвоичныхДанныхИзСтроки(пДанные);
	КлючБуфер = ПолучитьБуферДвоичныхДанныхИзСтроки(пКлюч);
	//РазмерБлока = 128; // Размер блока для HMAC512 - 128
	
	Если КлючБуфер.Размер > РазмерБлока Тогда
		КлючБуфер = SHA512(КлючБуфер);
	КонецЕсли;
	
	opad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("5c", РазмерБлока));
	ipad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("36", РазмерБлока));

	ipad.ЗаписатьПобитовоеИсключительноеИли(0, КлючБуфер);
	
	opad.ЗаписатьПобитовоеИсключительноеИли(0, КлючБуфер);
	
	Возврат нРег(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(SHA512(СклеитьБуферыДвоичныхДанных(opad, SHA512(СклеитьБуферыДвоичныхДанных(ipad, ДанныеДв))))));
КонецФункции // HMAC512(пКлюч, пДанные)  Экспорт

// ВспомогательнаяФункция для запуска хеширования из HMAC функции с готовыми параметрами
// 
Функция SHA2_(пДанные, пБитность, пРазмер)
	Если пБитность>256 Тогда
		Возврат SHA512(пДанные, пРазмер);
	Иначе
		Возврат SHA256(пДанные, пРазмер);
	КонецЕсли;
КонецФункции // SHA2_(пДанные, пБитность, пРазмер)

// Функция расчета Хеша по алгоритму SHA2-512
// Входной параметр - двоичные данные
// Возвращаяет HEX строку с хешем
//
Функция SHA256(Знач пБуфердвДанных, пРазмер="256") Экспорт
	//Пояснения:
	// Все переменные беззнаковые, имеют размер 32 бита и при вычислениях суммируются по модулю 2^32
	// message — исходное двоичное сообщение
	// m — преобразованное сообщение
	
	// Инициализация переменных
	// (первые 32 бита дробных частей квадратных корней первых восьми простых чисел [от 2 до 19]):
	Если пРазмер="256" Тогда
		h0 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("6A09E667");
		h1 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("BB67AE85");
		h2 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("3C6EF372");
		h3 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("A54FF53A");
		h4 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("510E527F");
		h5 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("9B05688C");
		h6 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("1F83D9AB");
		h7 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("5BE0CD19");
	ИначеЕсли пРазмер="224" Тогда
		h0 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("c1059ed8");
		h1 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("367cd507");
		h2 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("3070dd17");
		h3 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("f70e5939");
		h4 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("ffc00b31");
		h5 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("68581511");
		h6 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("64f98fa7");
		h7 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("befa4fa4");
	КонецЕсли;
	//Таблица констант
	//(первые 32 бита дробных частей кубических корней первых 64 простых чисел [от 2 до 311]):
	
	лСтрока = "
	|428A2F98,71374491,B5C0FBCF,E9B5DBA5,3956C25B,59F111F1,923F82A4,AB1C5ED5,
	|D807AA98,12835B01,243185BE,550C7DC3,72BE5D74,80DEB1FE,9BDC06A7,C19BF174,
	|E49B69C1,EFBE4786,0FC19DC6,240CA1CC,2DE92C6F,4A7484AA,5CB0A9DC,76F988DA,
	|983E5152,A831C66D,B00327C8,BF597FC7,C6E00BF3,D5A79147,06CA6351,14292967,
	|27B70A85,2E1B2138,4D2C6DFC,53380D13,650A7354,766A0ABB,81C2C92E,92722C85,
	|A2BFE8A1,A81A664B,C24B8B70,C76C51A3,D192E819,D6990624,F40E3585,106AA070,
	|19A4C116,1E376C08,2748774C,34B0BCB5,391C0CB3,4ED8AA4A,5B9CCA4F,682E6FF3,
	|748F82EE,78A5636F,84C87814,8CC70208,90BEFFFA,A4506CEB,BEF9A3F7,C67178F2";
	Конст = ПолучитьМассивБДДИзHexСтроки(лСтрока);
	
	//Предварительная обработка:
	
	////	msg = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(СклеитьДвоичныеДанные(лДвД, ПолучитьДвоичныеДанныеИзHexСтроки("80")));
	
	L = пБуфердвДанных.Размер*8; // получаем размер в битах
//	K1 = 512 - ((L + 64 + 1) % 512); // сколько бит нужно добавить
	K1 = 512 - ((L + 64 + 1) % 512); // сколько бит нужно добавить
	K = K1 - 7; // Потому что засчитали один бит, а добавлять будем целый байт с лидирующим битом
	КолвоHEX = K/8; // считаем количество добавляемых байтов
	лБуферДвДанных = Новый БуферДвоичныхДанных(КолвоHEX,ПорядокБайтов.BigEndian);
	лМассивБухДвДанных = Новый Массив();
	лМассивБухДвДанных.Добавить(пБуфердвДанных);
	лМассивБухДвДанных.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки("80"));
	лМассивБухДвДанных.Добавить(лБуферДвДанных);
	
	лБуферДвДанных2 = Новый БуферДвоичныхДанных(8,ПорядокБайтов.BigEndian);
	
	лБуферДвДанных2.ЗаписатьЦелое64(0,L,ПорядокБайтов.BigEndian);
	лМассивБухДвДанных.Добавить(лБуферДвДанных2);
	
	пБуфердвДанных = СоединитьБуферыДвоичныхДанных(лМассивБухДвДанных,,ПорядокБайтов.BigEndian);
	
	
	//m := m ǁ [k нулевых бит], где k — наименьшее неотрицательное число, такое что 
	//                 (L + 1 + K) mod 512 = 448, где L — число бит в сообщении (сравнима по модулю 512 c 448)
	//m := m ǁ Длина(message) — длина исходного сообщения в битах в виде 64-битного числа
	//            с порядком байтов от старшего к младшему
	
	лМассив = РазделитьДвоичныеДанные(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(пБуфердвДанных),64);
	
	h_0 = h0.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_1 = h1.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_2 = h2.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_3 = h3.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_4 = h4.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_5 = h5.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_6 = h6.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	h_7 = h7.ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
	
	Для Каждого лКусок1 Из лМассив Цикл
		лМассив2 = РазделитьДвоичныеДанные(лКусок1,4);
		Для i=16 По 63 Цикл
			лЦел15 = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-15]).ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
			лЦел2 = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-2]).ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian);
			s0 = ПобитовоеИсключительноеИли(ПобитовоеИсключительноеИли(ЦиклическийСдвигВправо(лЦел15,7),ЦиклическийСдвигВправо(лЦел15,18)),ПобитовыйСдвигВправо(лЦел15,3));
			s1 = ПобитовоеИсключительноеИли(ПобитовоеИсключительноеИли(ЦиклическийСдвигВправо(лЦел2,17),ЦиклическийСдвигВправо(лЦел2,19)),ПобитовыйСдвигВправо(лЦел2,10));
			лБуфер32 = Новый БуферДвоичныхДанных(4,ПорядокБайтов.BigEndian);
			лЦел32 = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-16]).ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian) + s0 + ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-7]).ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian) + s1;
			лЦел32 = ПривестиК32Битам(лЦел32);
			лБуфер32.ЗаписатьЦелое32(0,лЦел32,ПорядокБайтов.BigEndian);
			лМассив2.Добавить(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(лБуфер32));
		КонецЦикла;
		
		//Далее сообщение обрабатывается последовательными порциями по 512 бит:
		//разбить сообщение на куски по 512 бит
		
		//для каждого куска
		//    разбить кусок на 16 слов длиной 32 бита (с порядком байтов от старшего к младшему внутри слова): w[0..15]
		
		//    Сгенерировать дополнительные 48 слов:
		//    для i от 16 до 63
		//        s0 := (w[i-15] rotr 7) xor (w[i-15] rotr 18) xor (w[i-15] shr 3)
		//        s1 := (w[i-2] rotr 17) xor (w[i-2] rotr 19) xor (w[i-2] shr 10)
		//        w[i] := w[i-16] + s0 + w[i-7] + s1
		
		//    Инициализация вспомогательных переменных:
		a = h_0;
		b = h_1;
		c = h_2;
		d = h_3;
		e = h_4;
		f = h_5;
		g = h_6;
		h = h_7;
		//    Основной цикл:
		Для i=0 По 63 Цикл
			S0 = ПривестиК32Битам(ПобитовоеИсключительноеИли(ПобитовоеИсключительноеИли(ЦиклическийСдвигВправо(a, 2), ЦиклическийСдвигВправо(a, 13)), ЦиклическийСдвигВправо(a, 22)));
			Ma = ПривестиК32Битам(ПобитовоеИсключительноеИли(ПобитовоеИсключительноеИли(ПобитовоеИ(a, b), ПобитовоеИ(a, c)), ПобитовоеИ(b, c)));
			t2 = ПривестиК32Битам(S0 + Ma);
			S1 = ПривестиК32Битам(ПобитовоеИсключительноеИли(ПобитовоеИсключительноеИли(ЦиклическийСдвигВправо(e, 6), ЦиклическийСдвигВправо(e, 11)), ЦиклическийСдвигВправо(e, 25)));
			Ch = ПривестиК32Битам(ПобитовоеИсключительноеИли(ПобитовоеИ(e, f), ПобитовоеИ(ПобитовоеНе(e), g)));
			t1 = ПривестиК32Битам(h + S1 + Ch + Конст[i].ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian) + ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i]).ПрочитатьЦелое32(0,ПорядокБайтов.BigEndian));
			h = g;
			g = f;
			f = e;
			e = ПривестиК32Битам(d + t1);
			d = c;
			c = b;
			b = a;
			a = ПривестиК32Битам(t1 + t2);
		КонецЦикла;
		
		h_0 = ПривестиК32Битам(h_0 + a);
		h_1 = ПривестиК32Битам(h_1 + b);
		h_2 = ПривестиК32Битам(h_2 + c);
		h_3 = ПривестиК32Битам(h_3 + d);
		h_4 = ПривестиК32Битам(h_4 + e);
		h_5 = ПривестиК32Битам(h_5 + f);
		h_6 = ПривестиК32Битам(h_6 + g);
		h_7 = ПривестиК32Битам(h_7 + h);
		
	КонецЦикла;
	
	h0.ЗаписатьЦелое32(0,h_0,ПорядокБайтов.BigEndian);
	h1.ЗаписатьЦелое32(0,h_1,ПорядокБайтов.BigEndian);
	h2.ЗаписатьЦелое32(0,h_2,ПорядокБайтов.BigEndian);
	h3.ЗаписатьЦелое32(0,h_3,ПорядокБайтов.BigEndian);
	h4.ЗаписатьЦелое32(0,h_4,ПорядокБайтов.BigEndian);
	h5.ЗаписатьЦелое32(0,h_5,ПорядокБайтов.BigEndian);
	h6.ЗаписатьЦелое32(0,h_6,ПорядокБайтов.BigEndian);
	h7.ЗаписатьЦелое32(0,h_7,ПорядокБайтов.BigEndian);
	
	лМассив3 = Новый Массив();
	лМассив3.Добавить(h0);
	лМассив3.Добавить(h1);
	лМассив3.Добавить(h2);
	лМассив3.Добавить(h3);
	лМассив3.Добавить(h4);
	лМассив3.Добавить(h5);
	лМассив3.Добавить(h6);
	Если пРазмер = "256" Тогда
		лМассив3.Добавить(h7);
	КонецЕсли;
	Буфер3 = СоединитьБуферыДвоичныхДанных(лМассив3);
	Возврат Буфер3;
КонецФункции // SHA256(Знач пБуфердвДанных, пРазмер="256") Экспорт

// Функция расчета Хеша по алгоритму SHA2-512
// Входной параметр - двоичные данные
// Возвращаяет HEX строку с хешем
//
Функция SHA512(Знач пБуфердвДанных, пРазмер="512") Экспорт
	//Пояснения:
	// Все переменные беззнаковые, имеют размер 64 бита и при вычислениях суммируются по модулю 2^64
	// message — исходное двоичное сообщение
	// m — преобразованное сообщение
	
	// Инициализация переменных
	// (первые 64 бита дробных частей квадратных корней первых восьми простых чисел [от 2 до 19]):
	
	Если пРазмер = "512" Тогда
		h0 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("6a09e667f3bcc908");
		h1 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("bb67ae8584caa73b");
		h2 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("3c6ef372fe94f82b");
		h3 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("a54ff53a5f1d36f1");
		h4 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("510e527fade682d1");
		h5 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("9b05688c2b3e6c1f");
		h6 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("1f83d9abfb41bd6b");
		h7 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("5be0cd19137e2179");
	ИначеЕсли пРазмер = "384" Тогда
		h0 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("CBBB9D5DC1059ED8");
		h1 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("629A292A367CD507");
		h2 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("9159015A3070DD17");
		h3 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("152FECD8F70E5939");
		h4 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("67332667FFC00B31");
		h5 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("8EB44A8768581511");
		h6 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("DB0C2E0D64F98FA7");
		h7 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("47B5481DBEFA4FA4");
	ИначеЕсли пРазмер = "256" Тогда
		h0 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("22312194FC2BF72C");
		h1 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("9F555FA3C84C64C2");
		h2 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("2393B86B6F53B151");
		h3 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("963877195940EABD");
		h4 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("96283EE2A88EFFE3");
		h5 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("BE5E1E2553863992");
		h6 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("2B0199FC2C85B8AA");
		h7 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("0EB72DDC81C52CA2");
	ИначеЕсли пРазмер = "224" Тогда
		h0 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("8C3D37C819544DA2");
		h1 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("73E1996689DCD4D6");
		h2 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("1DFAB7AE32FF9C82");
		h3 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("679DD514582F9FCF");
		h4 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("0F6D2B697BD44DA8");
		h5 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("77E36F7304C48942");
		h6 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("3F9D85A86A1D36C8");
		h7 = ПолучитьБуферДвоичныхДанныхИзHexСтроки("1112E6AD91D692A1");
	КонецЕсли;
	
	//Таблица констант
	//(первые 64 бита дробных частей кубических корней первых 80 простых чисел [от 2 до 409]):
	
	лМассивСтепеней2 = ПолучитьМассивСтепеней2();
	
	лСтрока = "
	|428a2f98d728ae22,7137449123ef65cd,b5c0fbcfec4d3b2f,e9b5dba58189dbbc,
	|3956c25bf348b538,59f111f1b605d019,923f82a4af194f9b,ab1c5ed5da6d8118,
	|d807aa98a3030242,12835b0145706fbe,243185be4ee4b28c,550c7dc3d5ffb4e2,
	|72be5d74f27b896f,80deb1fe3b1696b1,9bdc06a725c71235,c19bf174cf692694,
	|e49b69c19ef14ad2,efbe4786384f25e3,0fc19dc68b8cd5b5,240ca1cc77ac9c65,
	|2de92c6f592b0275,4a7484aa6ea6e483,5cb0a9dcbd41fbd4,76f988da831153b5,
	|983e5152ee66dfab,a831c66d2db43210,b00327c898fb213f,bf597fc7beef0ee4,
	|c6e00bf33da88fc2,d5a79147930aa725,06ca6351e003826f,142929670a0e6e70,
	|27b70a8546d22ffc,2e1b21385c26c926,4d2c6dfc5ac42aed,53380d139d95b3df,
	|650a73548baf63de,766a0abb3c77b2a8,81c2c92e47edaee6,92722c851482353b,
	|a2bfe8a14cf10364,a81a664bbc423001,c24b8b70d0f89791,c76c51a30654be30,
	|d192e819d6ef5218,d69906245565a910,f40e35855771202a,106aa07032bbd1b8,
	|19a4c116b8d2d0c8,1e376c085141ab53,2748774cdf8eeb99,34b0bcb5e19b48a8,
	|391c0cb3c5c95a63,4ed8aa4ae3418acb,5b9cca4f7763e373,682e6ff3d6b2b8a3,
	|748f82ee5defb2fc,78a5636f43172f60,84c87814a1f0ab72,8cc702081a6439ec,
	|90befffa23631e28,a4506cebde82bde9,bef9a3f7b2c67915,c67178f2e372532b,
	|ca273eceea26619c,d186b8c721c0c207,eada7dd6cde0eb1e,f57d4f7fee6ed178,
	|06f067aa72176fba,0a637dc5a2c898a6,113f9804bef90dae,1b710b35131c471b,
	|28db77f523047d84,32caab7b40c72493,3c9ebe0a15c9bebc,431d67c49c100d4c,
	|4cc5d4becb3e42b6,597f299cfc657e2a,5fcb6fab3ad6faec,6c44198c4a475817";
	Конст = ПолучитьМассивБДДИзHexСтроки(лСтрока);
	
	//Предварительная обработка:
	//m := m ǁ [k нулевых бит], где k — наименьшее неотрицательное число, такое что 
	//                 (L + 1 + K) mod 1024 = 960, где L — число бит в сообщении (сравнима по модулю 1024 c 960)
	
	//m := m ǁ Длина(message) — длина исходного сообщения в битах в виде 64-битного числа
	//            с порядком байтов от старшего к младшему
	лРазмер = пБуфердвДанных.Размер%128;
	K_1 = 112 - лРазмер;
	Если лРазмер >= 112 Тогда
		K_1 = K_1 + 128;
	КонецЕсли;
	КолвоHEX_ = K_1 + 7;
	L = пБуфердвДанных.Размер*8; // получаем размер в битах
	лБуферДвДанных = Новый БуферДвоичныхДанных(КолвоHEX_,ПорядокБайтов.BigEndian);
	лМассивБухДвДанных = Новый Массив();
	лМассивБухДвДанных.Добавить(пБуфердвДанных);
	лМассивБухДвДанных.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки("80"));
	лМассивБухДвДанных.Добавить(лБуферДвДанных);
	
	лБуферДвДанных2 = Новый БуферДвоичныхДанных(8,ПорядокБайтов.BigEndian);
	
	лБуферДвДанных2.ЗаписатьЦелое64(0,L,ПорядокБайтов.BigEndian);
	лМассивБухДвДанных.Добавить(лБуферДвДанных2);
	
	лБуфердвДанных4 = СоединитьБуферыДвоичныхДанных(лМассивБухДвДанных,,ПорядокБайтов.BigEndian);
	
	//разбить сообщение на куски по 1024 бит
	лМассив = РазделитьДвоичныеДанные(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(лБуфердвДанных4),128);
	
	h_0 = h0.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_1 = h1.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_2 = h2.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_3 = h3.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_4 = h4.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_5 = h5.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_6 = h6.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	h_7 = h7.ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
	
	//Далее сообщение обрабатывается последовательными порциями по 1024 бит:
	Для Каждого лКусок1 Из лМассив Цикл
		//    разбить кусок на 16 слов длиной 64 бита (с порядком байтов от старшего к младшему внутри слова): w[0..15]
		лМассив2 = РазделитьДвоичныеДанные(лКусок1,8);
		Для i=16 по 79 Цикл
			лЦел15 = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-15]).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
			лЦел2 = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-2]).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian);
			//    Сгенерировать дополнительные 48 слов:
			//    для i от 16 до 63
			//        s0 := (w[i-15] rotr 7) xor (w[i-15] rotr 18) xor (w[i-15] shr 3)
			//        s1 := (w[i-2] rotr 17) xor (w[i-2] rotr 19) xor (w[i-2] shr 10)
			//        w[i] := w[i-16] + s0 + w[i-7] + s1
			s0 = ПобитовоеИсключительноеИли64(ПобитовоеИсключительноеИли64(ЦиклическийСдвигВправо64(лМассивСтепеней2,лЦел15,1),ЦиклическийСдвигВправо64(лМассивСтепеней2,лЦел15,8)),Цел(лЦел15/128));
			s1 = ПобитовоеИсключительноеИли64(ПобитовоеИсключительноеИли64(ЦиклическийСдвигВправо64(лМассивСтепеней2,лЦел2,19),ЦиклическийСдвигВправо64(лМассивСтепеней2,лЦел2,61)),Цел(лЦел2/64));
			лБуфер64 = Новый БуферДвоичныхДанных(8,ПорядокБайтов.BigEndian);
			лЦел64 = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-16]).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian) + s0 + ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i-7]).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian) + s1;
			лЦел64 = ПривестиК64Битам(лЦел64);
			лБуфер64.ЗаписатьЦелое64(0,лЦел64,ПорядокБайтов.BigEndian);
			лМассив2.Добавить(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(лБуфер64));
		КонецЦикла;
		
		//    Инициализация вспомогательных переменных:
		a = h_0;
		b = h_1;
		c = h_2;
		d = h_3;
		e = h_4;
		f = h_5;
		g = h_6;
		h = h_7;
		//    Основной цикл:
		Для i = 0 по 79 Цикл
			S0 = ПривестиК64Битам(ПобитовоеИсключительноеИли64(ПобитовоеИсключительноеИли64(ЦиклическийСдвигВправо64(лМассивСтепеней2,a, 28), ЦиклическийСдвигВправо64(лМассивСтепеней2,a, 34)), ЦиклическийСдвигВправо64(лМассивСтепеней2,a, 39)));
			Ma = ПривестиК64Битам(ПобитовоеИсключительноеИли64(ПобитовоеИсключительноеИли64(ПобитовоеИ64(a, b), ПобитовоеИ64(a, c)), ПобитовоеИ64(b, c)));
			t2 = ПривестиК64Битам(S0 + Ma);
			S1 = ПривестиК64Битам(ПобитовоеИсключительноеИли64(ПобитовоеИсключительноеИли64(ЦиклическийСдвигВправо64(лМассивСтепеней2,e, 14), ЦиклическийСдвигВправо64(лМассивСтепеней2,e, 18)), ЦиклическийСдвигВправо64(лМассивСтепеней2,e, 41)));
			Ch = ПривестиК64Битам(ПобитовоеИсключительноеИли64(ПобитовоеИ64(e, f), ПобитовоеИ64(ПобитовоеНе64(e), g)));
			t1 = ПривестиК64Битам(h + S1 + Ch + Конст[i].ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian) + ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(лМассив2[i]).ПрочитатьЦелое64(0,ПорядокБайтов.BigEndian));
			h = g;
			g = f;
			f = e;
			e = ПривестиК64Битам(d + t1);
			d = c;
			c = b;
			b = a;
			a = ПривестиК64Битам(t1 + t2);
		КонецЦикла;
		
		//    Добавить полученные значения к ранее вычисленному результату:
		h_0 = ПривестиК64Битам(h_0 + a);
		h_1 = ПривестиК64Битам(h_1 + b);
		h_2 = ПривестиК64Битам(h_2 + c);
		h_3 = ПривестиК64Битам(h_3 + d);
		h_4 = ПривестиК64Битам(h_4 + e);
		h_5 = ПривестиК64Битам(h_5 + f);
		h_6 = ПривестиК64Битам(h_6 + g);
		h_7 = ПривестиК64Битам(h_7 + h);
		
	КонецЦикла;
	
	h0.ЗаписатьЦелое64(0,h_0,ПорядокБайтов.BigEndian);
	h1.ЗаписатьЦелое64(0,h_1,ПорядокБайтов.BigEndian);
	h2.ЗаписатьЦелое64(0,h_2,ПорядокБайтов.BigEndian);
	h3.ЗаписатьЦелое64(0,h_3,ПорядокБайтов.BigEndian);
	h4.ЗаписатьЦелое64(0,h_4,ПорядокБайтов.BigEndian);
	h5.ЗаписатьЦелое64(0,h_5,ПорядокБайтов.BigEndian);
	h6.ЗаписатьЦелое64(0,h_6,ПорядокБайтов.BigEndian);
	h7.ЗаписатьЦелое64(0,h_7,ПорядокБайтов.BigEndian);
	
	//Получить итоговое значение хеша:
	//digest = hash = h0 ǁ h1 ǁ h2 ǁ h3 ǁ h4 ǁ h5 ǁ h6 ǁ h7
	лМассив3 = Новый Массив();
	лМассив3.Добавить(h0);
	лМассив3.Добавить(h1);
	лМассив3.Добавить(h2);
	// Поскольку итоговый результат берётся не весь, то добавляем в массив нужное количество слов в зависимости от размера вывода.
	Если пРазмер = "224" Тогда
		// "распилить пополам" и взять "старшую" часть т.к. нужно взять 3.5 QWORD (64-х разрядных слова).
		лМассив3.Добавить(ПолучитьБуферДвоичныхДанныхИзHexСтроки(Лев(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(h3),8)));
	Иначе
		лМассив3.Добавить(h3);
	КонецЕсли;
	Если пРазмер = "384" ИЛИ пРазмер = "512" Тогда
		лМассив3.Добавить(h4);
		лМассив3.Добавить(h5);
	КонецЕсли;
	Если пРазмер = "512" Тогда
		лМассив3.Добавить(h6);
		лМассив3.Добавить(h7);
	КонецЕсли;
	Буфер3 = СоединитьБуферыДвоичныхДанных(лМассив3);
	Возврат Буфер3;
КонецФункции // SHA512(Знач пБуфердвДанных, пРазмер="512") Экспорт

#КонецОбласти

#Область SHA3

// Функция расчета Хеша по алгоритму SHA3 с ключом
// Возвращает hex строку
// Входные параметры:
// пКлюч - строка с ключом, неограниченная, приводится к длине блока - 128
// пДанные - строка с данными, неограниченная
// пСтандарт - строка с описанием стандарта, варианты: "SHA3-128", "SHA3-224", "SHA3-256", "SHA3-384", "SHA3-512", "Keccak-256", "Keccak-512", "SHAKE128", "SHAKE256", "cSHAKE128", "cSHAKE256" 
// Возвращаяет Hex строку с хешем
//
Функция HMACSHA3(пДанные, пКлюч="", пСтандарт="SHA3-512") Экспорт
	
	ДанныеДв = ПолучитьДвоичныеДанныеИзСтроки(пДанные);
	КлючДв = ПолучитьДвоичныеДанныеИзСтроки(пКлюч);
	
	СоответствиеСтандартаИАлгоритма = ПолучитьСоответствияСтандартов3();
	лСтандарт = СоответствиеСтандартаИАлгоритма[пСтандарт];
	
	РазмерБлока = (1600-лСтандарт.Битность)/8; // Размер блока для HMAC512 - 128
	
	Если КлючДв.Размер() > РазмерБлока Тогда
		КлючHex = SHA3(КлючДв, пСтандарт);
	ИНаче
		КлючHex = ПолучитьHexСтрокуИзДвоичныхДанных(КлючДв);
	КонецЕсли;
	Если СтрДлина(КлючHex)/2 < РазмерБлока Тогда
		КлючHex = Лев(КлючHex + ПовторитьСтроку("00", РазмерБлока-СтрДлина(КлючHex)/2), РазмерБлока);
	КонецЕсли;
	
	КлючБуфер = ПолучитьБуферДвоичныхДанныхИзHexСтроки(КлючHex);
	
	opad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("5c", РазмерБлока));
	ipad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("36", РазмерБлока));

	ipad.ЗаписатьПобитовоеИсключительноеИли(0, КлючБуфер);
	ikeypad = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ipad);
	
	opad.ЗаписатьПобитовоеИсключительноеИли(0, КлючБуфер);
	okeypad = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(opad);
	
	Возврат SHA3(СклеитьДвоичныеДанные(okeypad, ПолучитьДвоичныеДанныеИзHexСтроки(SHA3(СклеитьДвоичныеДанные(ikeypad, ДанныеДв),пСтандарт))),пСтандарт);
	
КонецФункции

// Функция расчёта хеша по алгоритму SHA3, Keccak (кечак)
// Возвращает Hex строку
// Параметры:
// Данные - дв.данные с данными
// пСтандарт - стандрат по которому производится расчёт.
//  Варианты: "SHA3-128", "SHA3-224", "SHA3-256", "SHA3-384", "SHA3-512", "Keccak-256", "Keccak-512", "SHAKE128", "SHAKE256", "cSHAKE128", "cSHAKE256"
//
Функция SHA3(пДанные, пСтандарт="SHA3-512") Экспорт
	СоответствиеСтандартаИАлгоритма = ПолучитьСоответствияСтандартов3();
	лСтандарт = СоответствиеСтандартаИАлгоритма[пСтандарт];
	Возврат ПодготовитьИВыполнитьКечак(пДанные, лСтандарт.Битность, лСтандарт.Размер, лСтандарт.Суффикс, "80");
КонецФункции // SHA3(пДанные, пСтандарт="SHA3-512") Экспорт

// Функция подготавливает данные, дополняя их суффиксами между которыми нулевые байты, возвращает двоичные данные
// Возвращает двоичные данные
//  Параметры:
//   пДанные - Двоичные данные, которые нужно подготовить
//   пБитность - Количество бит, кратно которому должен получиться результат
//   пСуффикс1 - Hex строка с суффиксом 1 по умолчанию "06" для SHA3
//   пСуффикс2 - Hex строка с суффиксом 2 по уиолчанию "80"
//   
Функция ПодготовитьДанные(пДанные, пБитность, пСуффикс1="06", пСуффикс2="80")
	лРазмер = пДанные.Размер();
	лКолвБайт = пБитность/8;
	лРазница = лРазмер%лКолвБайт;
	лКолВоКДобавке = (лКолвБайт - лРазница);
	Если лКолВоКДобавке = 1 Тогда
		лСтрокаДополнения = СложитьHex(пСуффикс1,пСуффикс2);// "9f";//"86"; //пСуффикс1 + ПовторитьСтроку("00", лКолвБайт-1) + пСуффикс2;;
	Иначе
		лСтрокаДополнения = пСуффикс1 + ПовторитьСтроку("00", лКолВоКДобавке-2) + пСуффикс2;
		//лСтрокаДополнения = "01" + ПовторитьСтроку("00", лКолВоКДобавке-2) + "80"; // keccak
		//лСтрокаДополнения = "06" + ПовторитьСтроку("00", лКолВоКДобавке-2) + "80"; // sha3
	КонецЕсли;
	Возврат СклеитьДвоичныеДанные(пДанные, ПолучитьДвоичныеДанныеИзHexСтроки(лСтрокаДополнения));
КонецФункции // ПодготовитьДанные(пДанные, пБитность, пСуффикс1, пСуффикс2)

// Функция подготавливает данные и выполняет расчет хеша
// Возвращаяет hex строку
// Параметры:
//  пДанные - двоичные данные
//  пБитность - размер блока алгоритма в битах
//  пДлинаВыхода - размер выхода функции в битах
//  пСуффикс1 - суффикс добавляемый к входным данным, hex строка
//  пСуффикс2 - суффикс добавляемый к выходным данным дополненным первым суффиксом и нулевыми данными, hex строка
//
Функция ПодготовитьИВыполнитьКечак(пДанные, пБитность, пДлинаВыхода=0, пСуффикс1, пСуффикс2) Экспорт
	
	b = 1600; // размер буфера
	c = пБитность; // ёмкость;
	
	d = пДлинаВыхода;
	
	l = 6; // в SHA-3 приняты такие параметры Keccak
	
	r = b - c; // (200-2*(лРазмер/8))*8; // 576 для sha3-512
	//b = r + c; // b = 25*l; // 1600 размер буфера  	лРазмерБуфера = 1600; // Бит
	
	пДанные2 = ПодготовитьДанные(пДанные,r, пСуффикс1, пСуффикс2);

	msg = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(пДанные2); // Message
	
	Возврат Кечак(l,r,msg,d);
КонецФункции // ПодготовитьИВыполнитьКечак(пДанные, пБитность, пДлинаВыхода=0, пСуффикс1, пСуффикс2) Экспорт

// Собственно сам алгоритм
// Возвращает hex строку указанной длины d
// Параметры:
// l - задаёт длину обрабатываемого слова в битах, реализован алгоритм для l=6
// r - размер обрабатываемого блока в битах
// msg - данные в виде буфера двоичных данных
// d - длина выхода в битах
//
Функция Кечак(l,r,msg,d)
	
	w = Pow(2,l); // 64 бита слово  	лДлинаСлова = 64; // Бит
	m_blockSize = r / w * 8;  	// 72 = 200-2*(лРазмер/8);
	wb = w/8;
	// Инициализация массива 5 х 5 х w
	state = Новый Массив;
	Для x = 0 по 4 Цикл
		state.Добавить(Новый Массив);
		Для y = 0 по 4 Цикл
			state[x].Добавить(0); // Число будет обрабатываться как 64-х разрядное 2^_l
		КонецЦикла;
	КонецЦикла;
	
	лМассивСтепеней2 = ПолучитьМассивСтепеней2();
	
	// фаза впитывания
	
	i = 0;
	Пока i<msg.Размер Цикл
		j = 0;
		Пока j < r/w Цикл
            лТекБлок = msg.ПрочитатьЦелое64(i+j*wb,ПорядокБайтов.LittleEndian);
            x = j % 5;
            y = Цел(j / 5);
            state[x][y] = ПобитовоеИсключительноеИли64(state[x][y],лТекБлок);
			j = j + 1;
		КонецЦикла;
		ФункцияПерестановокКечак(лМассивСтепеней2,state,l,w);
		i = i + m_blockSize;
	КонецЦикла;
	
	// Фаза выжимки
	Z0 = "";
	лБуферZ = Новый БуферДвоичныхДанных(25*wb); // 200
	лДлинаВыхСтр = d/4; //  d/8*2   d/8 - байт и * 2 - символа hex на байт
	Пока СтрДлина(Z0) < лДлинаВыхСтр Цикл // для кечак и sha3 цикл проходит один раз
		k = 0;
		Для i=0 По 4 Цикл
			Для j=0 По 4 Цикл
				лБуферZ.ЗаписатьЦелое64(k,state[j][i],ПорядокБайтов.LittleEndian);
				k = k + 8;
			КонецЦикла;
		КонецЦикла;
		ФункцияПерестановокКечак(лМассивСтепеней2,state,l,w);
		Z0 = Z0 + ПолучитьHexСтрокуИзБуфераДвоичныхДанных(лБуферZ);
	КонецЦикла;
	Z = Лев(Z0,лДлинаВыхСтр);
	Возврат Нрег(Z);
КонецФункции // Кечак(l,r,msg,d)

Функция ФункцияПерестановокКечак(пМассивСтепеней2,a,l,w)
	nRounds = 12 + 2*l;
	
	лСтрока = "
	|0000000000000001,0000000000008082,800000000000808a,8000000080008000,
	|000000000000808b,0000000080000001,8000000080008081,8000000000008009,
	|000000000000008a,0000000000000088,0000000080008009,000000008000000a,
	|000000008000808b,800000000000008b,8000000000008089,8000000000008003,
	|8000000000008002,8000000000000080,000000000000800a,800000008000000a,
	|8000000080008081,8000000000008080,0000000080000001,8000000080008008";
	RC = ПолучитьМассивЧиселИзHexСтроки(лСтрока);
	
	Для r=0 По nRounds-1 Цикл
		
		// θ [Keccak §2.3.2]
		C = Новый Массив(5);
		D = Новый Массив(5);
		Для x=0 По 4 Цикл
			C[x] = a[x][0];
			Для y=1 По 4 Цикл
				C[x] = ПобитовоеИсключительноеИли64(C[x], a[x][y]);
			КонецЦикла;
		КонецЦикла;
		Для x=0 По 4 Цикл
			D[x] = ПобитовоеИсключительноеИли64(C[((x+4)%5)],ЦиклическийСдвигВлево64(пМассивСтепеней2,C[((x+1)%5)], 1));
			// a[x,y] = a[x,y] ⊕ D[x]
			Для y=0 По 4 Цикл
				a[x][y] = ПобитовоеИсключительноеИли64(a[x][y], D[x]);
			КонецЦикла;
		КонецЦикла;
		
		// ρ + π [Keccak §2.3.4]
		x = 1;
		y = 0;
		current = a[x][y];
		Для t=0 По nRounds-1 Цикл
			X1 = y;
			Y1 = (2*x + 3*y)%5;
			
			tmp = a[X1][Y1];
			a[X1][Y1] = ЦиклическийСдвигВлево64(пМассивСтепеней2,current, ((t+1)*(t+2)/2) % w);
			current = tmp;
			x = X1;
			y = Y1;
		КонецЦикла;
        // χ [Keccak §2.3.1]
        Для y=0 По 4 Цикл
            C = Новый Массив;
			Для x=0 По 4 Цикл
				C.Добавить(a[x][y]);
			КонецЦикла;
            Для x=0 По 4 Цикл
                a[x][y] = ПобитовоеИсключительноеИли64(C[x], ПобитовоеИ64(ПобитовоеНе64(C[(x+1)%5]),  C[(x+2)%5]));
            КонецЦикла;
        КонецЦикла;

        // ι [Keccak §2.3.5]
        a[0][0] = ПобитовоеИсключительноеИли64(a[0][0], RC[r]);
	КонецЦикла;
	Возврат Неопределено;
КонецФункции // ФункцияПерестановокКечак(a,l,w)  

#КонецОбласти
